1. #### 功能模块及层次结构
   1. 初始化棋盘（formatboard、printboard）
   2. 棋子移动相关：选中棋子（clk）
      - 更新棋盘（uptoking）
      - 切换玩家（changeplayer）
      - 计算可移动位置（makemove）
      - 计算可吃子棋子移动位置（makepeatmove、make

keatmove）
   - 计算非吃子棋子移动位置（makefmove、makekmove）
   - 执行棋子移动（domove）

#### 调用关系
1. 初始化棋盘：formatboard -> printboard
2. 选中棋子：clk -> uptoking -> changeplayer -> makemove
3. 计算可移动位置：makemove -> makepeatmove、makekeatmove、makefmove、makekmove
4. 执行棋子移动：domove

#### 模块间接口
1. boarda：表示棋盘上的棋子位置，0 表示空位，1 表示白棋，2 表示黑棋。
2. nowplay：表示当前轮到哪个玩家，1 为白棋，2 为黑棋。
3. sltstone：表示选中的棋子。
4. smovea、semovea、sestonea 等数组：用于存储可移动的位置和可吃子的位置。

#### 详细设计

1. 初始化棋盘：创建一个大小为 50 的数组，用于表示棋盘上的棋子位置，然后调用 printboard 函数更新网页上的棋盘显示。
2. 选中棋子：当用户点击棋子时，触发 clk 函数。根据选中的棋子和当前玩家，执行以下操作：
   - 更新棋盘：调用 uptoking 函数判断是否需要将普通棋子升为王棋。
   - 切换玩家：调用 changeplayer 函数，切换当前玩家，并计算新玩家的可移动位置。
3. 计算可移动位置：makemove 函数负责计算当前玩家的可移动位置，包括可吃子的位置和非吃子的位置。各种移动位置的计算分别由 makepeatmove、makekeatmove、makefmove 和 makekmove 函数实现。
4. 执行棋子移动：根据计算出的可移动位置，执行相应的棋子移动操作，并更新棋盘。



这一段代码主要包含以下功能模块：

1. 更新棋子为王棋（uptoking）：当棋子到达对方底线时，将棋子升级为王棋。
2. 切换玩家（changeplayer）：当一方完成操作后，切换到另一个玩家进行操作。
3. 更新玩家（upplay）：执行当前玩家的移动操作。
4. 生成移动（makemove）：生成当前玩家的所有可能移动和吃子操作。
5. 执行吃子操作（makepeatmove）：递归遍历生成所有可能的吃子操作。
6. 随机移动（randommove）：在可行的操作中随机选择一个。
7. 搜索移动（searchmove）：通过递归搜索，评估每个可能的移动操作并选择最佳操作。

这段代码包含了以下功能：

1. `uptoking(p)`：检查某个位置的棋子是否应该升为王，并进行升级。

2. `changeplayer()`：在玩家之间切换回合，调用 `upplay()` 或者 `makemove()`、`addpointer()`。

3. `upplay()`：计算电脑玩家的下一步棋，并执行该步骤。

4. `makemove()`：根据当前玩家，计算所有可吃子的位置（`semovea` 和 `sestonea`）以及可移动的位置（`smovea`）。

5. `makepeatmove(clr, sf, ss)`：递归地计算给定棋子的所有连续吃子路径。

6. `gamevalue()`：计算当前棋盘的估值，包括棋子数量、可移动位置和棋子靠近对方基地的程度。

7. `choosemove()`：从可吃子的位置（`semovea` 和 `sestonea`）或可移动的位置（`smovea`）中随机选择一步。

   8. `domove()`：执行计算出的下一步棋，包括普通移动和吃子操作。

   这些功能模块共同实现了游戏的交互逻辑和电脑玩家的 AI 行为。在电脑玩家的回合中，代码首先计算所有可吃子和可移动的位置，然后根据游戏估值选择下一步棋。在执行移动和吃子操作时，代码会对棋盘进行相应的更新，并在必要时将棋子升级为王。最后，切换到下一个玩家的回合。

主要实现了以下功能：

1. 更新王棋的位置（uptoking）：如果普通棋子到达对方底线，将其升级为王棋。

2. 切换玩家（changeplayer）：在当前玩家完成移动后，切换到另一个玩家。

3. 更新玩家的操作（upplay）：对 AI 玩家进行移动策略的更新。

4. 生成移动路径（makemove）：根据当前棋盘状态，为玩家生成可移动和可吃子的路径。

5. 生成普通棋子的吃子路径（makepeatmove）：递归生成普通棋子在一次连续吃子过程中的所有可能路径。

   6. 棋子移动（stonemove）：将棋子从一个位置移动到另一个位置，并更新棋盘。

   7. 棋子吃子（stoneeat）：在棋子移动过程中，消除被吃掉的棋子。

   8. 结束游戏（toend）：在游戏结束时，显示输赢结果并重置游戏。

      9. 点击事件处理（clk）：根据玩家的点击操作，执行相应的棋子选中、移动、吃子等操作。
      10. 切换棋子图片（changestoneimg）：改变棋子的图片资源。
      11. 按钮点击事件处理（clkb）：根据按钮状态，执行重新开始游戏或切换棋子图片的操作。

      这些功能模块相互配合，共同实现了 100 格国际跳棋的游戏逻辑。

